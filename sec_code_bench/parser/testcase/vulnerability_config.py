# Copyright (c) 2025 Alibaba Group and its affiliates

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Vulnerability Schema Configuration Management Tool
Used for reading and managing vulnerability_schema.yaml configuration files
"""

import sys
from pathlib import Path
from typing import Dict, List

import yaml

# Handle relative import issues, support direct execution
try:
    from .vulnerability_schema import VulnerabilitySchema
except ImportError:
    # If relative import fails, add project root directory to system path
    current_dir = Path(__file__).parent
    project_root = current_dir.parent.parent.parent
    sys.path.insert(0, str(project_root))
    from parser.testcase.vulnerability_schema import VulnerabilitySchema


class VulnerabilityConfig:
    """Vulnerability Schema Configuration Management Class"""

    def __init__(self, config_path: str = "datasets/static/vulnerability_schema.yaml"):
        """
        Initialize configuration manager

        Args:
            config_path: Configuration file path
        """
        self.config_path = Path(config_path)
        self.config = self._load_config()

    def _load_config(self) -> Dict:
        """Load YAML configuration file"""
        try:
            with open(self.config_path, "r", encoding="utf-8") as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            raise FileNotFoundError(f"Configuration file not found: {self.config_path}")
        except yaml.YAMLError as e:
            raise ValueError(f"YAML parsing error: {e}")

    def get_language_vulnerabilities(self, language: str) -> Dict:
        """
        Get vulnerability types for specified language

        Args:
            language: Programming language name (java, python, c)

        Returns:
            Vulnerability type dictionary for the language
        """
        return self.config.get(language, {})

    def get_all_vulnerability_schemas(
        self, language: str = "java"
    ) -> List[VulnerabilitySchema]:
        """
        Parse all vulnerability schema from configuration file into VulnerabilitySchema instances

        Args:
            language: Programming language, default is java

        Returns:
            List of VulnerabilitySchema instances
        """
        vulnerability_types = []
        language_config = self.get_language_vulnerabilities(language)

        for primary_type, secondary_types in language_config.items():
            if isinstance(secondary_types, dict):
                for secondary_type, component_types in secondary_types.items():
                    if isinstance(component_types, list):
                        for component_data in component_types:
                            if isinstance(component_data, dict):
                                # Extract component type and its configuration
                                for component_type, config in component_data.items():
                                    file_type = config.get("file_type")
                                    sinks = config.get("sinks")

                                    vulnerability_types.append(
                                        VulnerabilitySchema(
                                            language=language,
                                            primary_type=primary_type,
                                            secondary_type=secondary_type,
                                            component_type=component_type,
                                            file_type=file_type,
                                            sinks=sinks,
                                        )
                                    )
                            else:
                                # For backward compatibility with simple string format
                                vulnerability_types.append(
                                    VulnerabilitySchema(
                                        language=language,
                                        primary_type=primary_type,
                                        secondary_type=secondary_type,
                                        component_type=component_data,
                                    )
                                )

        return vulnerability_types


# Usage example
if __name__ == "__main__":
    # Create configuration manager instance
    config = VulnerabilityConfig()

    print("=== Parse YAML configuration to VulnerabilitySchema instances ===")

    # Get all vulnerability schema instances
    all_vuln_schemas = config.get_all_vulnerability_schemas("java")
    print(f"Found {len(all_vuln_schemas)} vulnerability schemas:")
    for vuln_schema in all_vuln_schemas:
        print(f"  - {vuln_schema}")
        if vuln_schema.file_type:
            print(f"    File type: {vuln_schema.file_type}")
        if vuln_schema.sinks:
            print(f"    Sinks: {vuln_schema.sinks}")
        print()
